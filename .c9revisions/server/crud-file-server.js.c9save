{"ts":1347499986184,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var fs = require('fs');\r\nvar mime = require('mime');\r\nvar urlCleaner = require('./urlCleaner.js');\r\nvar error = require('./error.js');\r\nvar handlers = {\r\n    'GET': require('./get.js'),\r\n    'PUT': require('./put.js'),\r\n    'POST': require('./post.js'),\r\n    'DELETE': require('./delete.js'),\r\n    'HEAD': require('./head.js')\r\n};\r\n\r\n\r\n/*\r\nexample usage:\r\n\trequire('http').createServer(function (req, res) {\r\n\t\tserver.handleRequest(port, path, req, res, vpath);\r\n\t}).listen(port);\r\n*/\r\nexports.handleRequest = function(req, res, options) {\r\n\ttry {\r\n        // vpath: (optional) virtual path to host in the url\r\n        // path: the file system path to serve\r\n        // readOnly: whether to allow modifications to the file\r\n\r\n        options = options || {};\r\n        options.port = options.port || 80;\r\n        options.path = options.path || process.cwd();\r\n        options.vpath = (options.vpath || '').trimLeft();\r\n\r\n        if(options.path.lastIndexOf('/') !== options.path.length - 1) { options.path += '/'; } // make sure path ends with a slash\r\n        var parsedUrl = require('url').parse(req.url);\r\n        var query = query ? {} : require('querystring').parse(parsedUrl.query);\r\n        var url = urlCleaner.cleanUrl(parsedUrl.pathname);\r\n\r\n        // normalize the url such that there is no trailing or leading slash /\r\n        if(url.lastIndexOf('/') === url.length - 1) { url = url.slice(0, url.length ); }\r\n        if(url[0] === '/') { url = url.slice(1, url.length);  }\r\n\r\n        // check that url begins with vpath\r\n        if(options.vpath && url.indexOf(options.vpath) !== 0) {\r\n            console.log('url does not begin with vpath');\r\n            throw 'url [' + url + '] does not begin with vpath [' + options.vpath + ']';\r\n        }\r\n\r\n        var relativePath = options.vpath && url.indexOf(options.vpath) === 0 ?\r\n            options.path + url.slice(options.vpath.length + 1, url.length):\r\n            options.path + url;\r\n\r\n        if(req.method != 'HEAD') {\r\n            console.log(req.method + ' ' + req.url);\r\n        }\r\n\r\n\t\tif(options.readOnly && req.method != 'GET') {\r\n\t\t\terror.write(res, req.method + ' forbidden on this resource', 403);\r\n\t\t} else {\r\n            var handler = handlers[req.method];\r\n            if(handler) {\r\n                handler.handleRequest(req, res, options, relativePath, query, url);\r\n            } else {\r\n\t\t\t\tconsole.log('unsupported: ' + relativePath);\r\n\t\t\t\terror.write(res, 'Method ' + req.method + ' not allowed', 405);\r\n            }\r\n\t\t}\r\n\t} catch(err) {\r\n\t\t// file system ('fs') errors are just bubbled up to this error handler\r\n\t\t// for example, if the GET is called on a non-existent file, an error will be thrown\r\n\t\t// and caught here\r\n\t\t// writeError will write the error information to the response\r\n\t\terror.write(res, 'unhandled error: ' + err);\r\n\t}\r\n};\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2832}]],"length":2832}
{"contributors":[],"silentsave":false,"ts":1347500046269,"patch":[[{"diffs":[[0,"est("],[-1,"port, path, "],[0,"req, res"],[-1,", vpath"],[0,");\r\n"]],"start1":428,"start2":428,"length1":35,"length2":16}]],"length":2813,"saved":false}
